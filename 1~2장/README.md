# clean-architecture
만들면서 배우는 클린 아키텍처 
## 1장- 전통적인 계층형 아키텍처 구조의 문제점

- 전통적인 계층형 아키텍처 구조
: 웹, 도메인, 영속성 계층으로 이루어져 있음

```
각 계층의 역할은 다음과 같다.
1. 웹 계층
 : 웹과 가장 가까운 영역(표출단 계층)
2. 도메인 계층
 : 비즈니스 로직을 수행하는 영역(서비스 계층)
3. 영속성 계층
 : 데이터베이스와 가장 가까운 계층(매퍼 계층)
```

: 계층간의 흐름은 상위 계층에서 하위계층으로 이어지며, 반대로 이루어질 수는 없다.


- 계층형 아키텍처 구조의 문제
```
1. 계층형 아키텍처는 데이터베이스 주도 설계를 유도한다.
 : 계층형 아키텍처의 각 계층의 의존성은 웹에서 도메인을 도메인에서 영속성 계층을 거쳐 최종적으로 데이터베이스를 향하게 하므로써 모든 계층이 데이터베이스를 바라보게 된다. 
 : 위와 같은 의존성을 가질 경우 어플리케이션(프로그램)을 개발하는데 있어, 도메인(서비스) 로직이 중심이 아닌 데이터베이스 중심의 개발이 이루어지게 된다. 
 : 데이터베이스 위주의 개발을 진행하다보면, 엔티티와 도메인간의 결합을 위해 ORM 프레임워크를 사용하게 되는데 이때, 도메인 계층과 영속성 계층 간에 강한 결합력이 생기게 되고, 추후 도메인 계층의 역할이 영속성 계층의 위임되는등의 문제가 발생하게 된다.

2. 계층형 아키텍처는 상위계층에서의 하위계층으로의 책임을 위임하기 쉽다.
 : 계층형 아키텍처에서 계층간의 이동은 상위계층에서 하위계층으로 이루어지고, 상위계층의 컴포넌트를 하위계층으로 쉽게 내려 이용할 수 있다.
 : 위와 같이 상위계층의 컴포넌트들이 지속적으로 하위계층으로 위임될 경우, 특정 계층이 지나치게 비대해질 수 있고, 계층간의 역할이 뒤섞여 유지보수가 어려워질 수 있다.

3. 유스케이스를 숨긴다.
 : 2번과 같이 계층간의 책임 위임이 빈번해질 경우, 계층간의 구분이 모호해져 추후 유스케이스를 수정하기 어려워진다. 

4. 동시 작업이 어렵다
 : 전통적인 계층형 아키텍처에서 모든 계층은 DB를 바라보고 있으므로, 개발의 진행순서는 영속성, 도메인, 웹 계층의 역순으로 순차적으로 이루어진다.
따라서, 각 계층에서의 동시적인 개발작업이 이루어지기 어렵다.

```

## 2장- 계층형 아키텍처의 대안

```
1. 단일 책임 원칙
 : 컴포넌트를 변경하는 이유는 오직 하나뿐이어야 한다.
  = 한 가지 컴포넌트는 오로지 하나의 일을 수행해야 한다.
 : 단일책임원칙은 각 계층의 의존성을 낮춰주는데 중요한 역할을 한다.

2. 의존성 역전의 원칙
 : 코드상의 어떤 의존성이든 그 방향을 바꿀 수 있어야 한다.
 : 전통적인 계층형 아키텍처에서 모든 컴포넌트들은 데이터베이스에 강한 의존성을 지닐 수 밖에 없었다.
 : 의존성 역전의 원칙은 이러한 강한 결합을 느슨하게 만들어주는데 도움이 된다.
 : 그림 2.2 에서는 도메인 계층에서의 리포지토리 인터페이스를 만들고, 그에 대한 구현체를 영속성 계층에 만들어 도메인 계층의 영속성 계층에 대한 의존성을 역전시켰다.
``` 

```
hexagonal 아키텍처
: 육각형 내부에는 엔티티 그리고 엔티티와 상호작용하는 유스케이스로 이루어져 있고, 육각형 바깥에는 어플리케이션과 소통하는 다양한 어댑터들이 존재한다.
: 육각형의 내부에서 외부로 향해서는 어떠한 의존성도 존재치 않고, 각각의 어댑터들과 유스케이스 간의 연결은 포트를 이용해서 이루어진다.
: 이로 인해 hexagonal 아키텍처는 '포트와 어뎁터 아키텍처'라고도 알려져 있다.
```

```
클린 아키텍처
: 종속성 규칙에 의해 계층간의 모든 의존성이 내부로 향하는 형태의 아키텍처
: 구조는 가장 내부에 엔티티가 있고, 순차적으로 이를 감싸는 유스케이스, 인터페이스 어뎁터, 인프라 계층 순으로 이루어져 있다.
: 클린 아키텍처는 각각의 계층에서 철저한 관심의 분리를 통해 의존성을 낮춰 각각의 계층에서의 관심사에 집중할 수 있도록 만들어주는 구조이다.
```

```
객체지향설계 원칙(SOLID)
1. 단일 책임 원칙(SRP) - 클래스(함수와 데이터를 결합한 집합)는 하나의 이유(액터)만으로 수정되어야 하며 하나의 책임/기능/역할을 가져야 한다.

2. 개방-폐쇄 원칙(OCP) - 객체는 확장할 수 있어야 하고, 변경에는 닫혀있어야 한다.

3. 리스코프 치환 원칙(LSP) - 상위 타입의 객체를 하위 타입의 객체로 치환해도 정상 동작해야 한다.

4. 인터페이스 분리 원칙(ISP) - 클라이언트는 자신이 사용하는 함수에만 의존해야 하며, 인터페이스는 더 작게 분리되어야 한다.

6. 의존 역전 원칙(DIP) - 고수준 모듈은 저수준 모듈(세부사항)을 의존해서는 안되며, 추상화에 의존해야 한다.
```

```
용어정리
1. 엔티티: 데이터베이스의 테이블에 대응하는 클래스
2. 레포지토리: ORM에 이용되는 인터페이스
3. ORM(Object Reational Mapping): 객체 관계 매핑을 위한 기술
4. 도메인: 데이터베이스 관점에서의 도메인은 엔티티의 속성들이 가질 수 있는 값들의 집합. 
	    : 책에서 이야기하는 도메인 모델이란 아키텍처 상의 도메인 계층을 객체지향 기법으로 구현하는 패턴을 의미한다.
5. 인터페이스: 상호간을 이어주는 매개체 = 상호간응 연결하기 위한 일종의 협약 ex> jpa
